### 알고리즘 스터디
#### 기간 : 20221118(금) ~ 20230224(금) - 14주간 매일 3문제 이상 
#### 약 300문제(14 * 7 * 3)
#### <문제풀이 기록>
###### 20221118(금) : 8문제
###### - 프로그래머스
- 2016년
- 나누어 떨어지는 숫자 배열
- 수박수박수박수박수박수
- 완주하지 못한 선수
- 이상한문자만들기 (다시풀기)
- 자릿수 더하기
- 자연수 뒤집기
- 내림차순으로 배치하기
###### 20221119(토) : 8문제
###### - 프로그래머스
- 정수 제곱근 판별
- 제일 작은 수 제거하기
- 콜라츠 추측
- 하샤드 수
- 3진법 뒤집기
- 최소직사각형
- 같은 숫자는 싫어
- 두 개 뽑아서 더하기
###### 20221120(월) : 6문제
###### - 프로그래머스
- 로또의 순위
- 모의고사 (다시풀기)
- 문자열 정렬하기 (다시풀기)
- 내림차순으로 배치하기
- 소수만들기
    - 필요한 개념 및 사용되는 알고리즘
      - 소수의 개념 : 1과 자기자신으로만 나눠지는 수
      - 알고리즘1 : 정수 하나가 주어졌을때 소수인지 판별하는 알고리즘
      - 알고리즘2 : 배열이 주어졌을때 서로다른 숫자를 골라서 더하는 알고리즘
    - 실행계획
      - 배열에서 서로 다른 숫자 3개를 골라 중복없이 모든 경우의 수를 더한다.
      - 각 더해진 수를 소수인지 판별해서 소수이면 answer를 1올린다.
    - 복습시 챌린지 과제
      - 3중포문사용하지 않고 도전해보기
      - 다른사람 소스코드 비교
- 숫자 문자열과 영단어
      
        // # 필요한 개념 및 알고리즘 예측
        // ## 아스키코드 a ~ z : 97 ~ 122 / 숫자 0 ~ 9 : 48 ~ 57
        // (int)s.charAt(i) => 아스키코드 추출
        // System.out.println((int)"0".charAt(0));
        // System.out.println((int)"9".charAt(0));
        // ## StringBuilder 사용법

        // # 실행계획
        // 각 문자에 접근해서 아스키코드를 보고 문자열과 숫자를 구분해서 배열로 각각 저장한다. -> StringBuilder 사용안함 / ArrayList 사용
        // 저장된 ArrayList를 순회하면서 숫자로된 문자는 숫자로 형변환시키고 문자로 된 숫자는 메소드를 만들어서 처리한다.
        // => 메소드 : 문자로 된 숫자를 정수타입 숫자로 변환시키는 메소드는 switch문으로 만들어서 작성한다. -> 다른 방법이 있는지 확인
        // 저장된 ArrayList는 문자열로 변형시킨다.
        // 숫자로 이뤄진 문자열을 answer에 int형으로 변환시켜서 저장한다. 그리고 제출한다.


        // # 풀면서 알게된것
        // ## ArrayList<String>으로 선언하고 s.charAt(i)으로 저장하면
        //    Character를 String에 저장하려고 해서 오류가 발생한다. -> substring으로 대체해서 문제풀이수행
        // ## String s = "string" + s.charAt(i); 를 하면 자동형변환이 일어나서 오류가 발생하지 않는다.
        // ## String 비교해서 값이 같으면 true 반환하기 : s1.equals(s2);
        // ## String을 int로 변환 : Integer.parseInt(str);

        // # 코드작성
        // ## 배열만들기
        // ### 포문으로 캐릭터순회를 한다.
        // ### 48 ~ 57사이에 있으면 숫자로 바로 어레이리스트에 저장한다.
        // ### 97 ~ 122사이에 있으면 문자가 시작되는 구간부터 캐릭터 덧셈을 수행한다.
        //     String tmpStr = ""을 선언하고 a~z 사이의 단어를 계속해서 더해나간다.
        //     그리고 만약 현재 i가 s.length()-1이면 tmpStr을 저장한다.
        //     또 만약 i+1이 아스키값으로 48 ~ 57사이에 있으면 tmpStr을 저장하고 tmpStr을 ""로 초기화한다.
        //     또 만약 tmpStr.length()>=3인 경우에 tmpStr을 영단어가 저장된
        //        배열과 비교해서 일치하면 tmpStr에 저장하고 tmpStr을 ""로 초기화한다.
- 시저 암호 (x)
- 신규 아이디 추천 (x)

###### 20221120(화) : 5문제
###### - 프로그래머스
- 약수의 개수와 덧셈
````
* 실행계획 *
for문으로 left부터 right까지 순회하면서
for문 i가 주어졌을때 약수를 구해서 배열에 저장하고 카운트한다. 
카운트해서 짝수이면 int sum을 생성해서 더하고 홀수이면 sum에서 뺀다.

* 작성하면서 배운것 *
-- 어레이리스트 초기화(모두 null로 설정하고 size를 0으로 선언) : list.clear();
-- 어레이리스트 크기 : list.size();
````

- 약수의 합
````
        // * 문제이해 *
        // ( 문제를 잘 해결하려면 적절한 질문을 찾아야한다.)
        // -> 적절한 질문 : 최대한 많은 부서가 구매하게 하려면 어떻게 해야하는가?
        // 즉, 최대한 많은 부서가 물품을 구매하기 위한 방법을 찾는 문제
        // : 금액이 적은 것 부터 구매하도록 하면 최대한 많은 물건을 살 수 있다.

        // * 실행계획 *
        // 주어진 배열을 오름차순정렬한다.
        // for문을 돌면서 만약 가장 작은예산부터 주어진 예산과 비교해서 각 부서의 예산이
        // 작으면 전체예산에서 각 부서의 예산을 빼고 answer를 +1해준다.
        // 그리고 answer를 리턴한다.

        // * 문제풀면서 배운것
        // -- 자바에서 정렬에 관해서 정리 --
        // int 배열 오름차순 정렬 : Arrays.sort(int[] arr);
        // int 배열 내림차순 정렬 :
        // Integer[] tmp = Arrays.stream(intArray).boxed().toArray(Integer[]::new); // 각 원소 int -> Integer형
        // Arrays.sort(tmp, Comparator.reverseOrder());
        // String 배열 오름차순 정렬 : Arrays.sort(String[] arr);
        // String 배열 내림차순 정렬 : Arrays.sort(String[] arr, Comparator.reverseOrder());
````

- 시저암호
````
        // # 실행계획
        // String s를 순회하면서 각 캐릭터별로 아스키값을 인식하여 소문자일때와 대문자일때와 소문자나 대문자가 아닐때로 나눈다.
        // 소문자와 대문자의 각 경우에서 문자의 아스키 값에 n으로 더해진 값이 최대값을 넘으면 최대값만큼 아스키값을 뺀 후 뺸 값을 (최소값-1)에 더한다.
        // 이렇게 해서 얻게 된 아스키값을 이용해서 캐릭터로 변환하여 문자열에 더해준다.
        // 소문자나 대문자가 아닐 때는 String s에 그대로 더해준다.

        // 이렇게 하면 안되나 헷깔림 왜냐면 0~25의 값이 나오는데 아래서 64에다가 n을 더해주게 됨 이러면 하나가 밀려서 출력됨
        // 초과시 64를 더해주는게 맞나? ㅇㅇ 64를 더해주는게 맞음(n의 범위가 1 ~ 25일때)
        // 'Z' + 1 -> 'A'(65) = 64 + 1
        // 'Z' + 2 -> 'B'(66) = 64 + 2
        // 'Z' + 25 -> 64 + 25 = (89)'Y'

        // # 아스키 코드값 추출
        //System.out.println((int)"a".charAt(0)); // 97
        //System.out.println((int)"z".charAt(0)); // 122
        //System.out.println((int)"A".charAt(0)); // 65
        //System.out.println((int)"Z".charAt(0)); // 90
````

- 예산
````
        // * 문제이해 *
        // 문제를 잘 해결하려면 적절한 질문을 찾아야한다.
        // -> 적절한 질문 : 최대한 많은 부서가 구매하게 하려면 어떻게 해야하는가?
        // 즉, 최대한 많은 부서가 물품을 구매하기 위한 방법을 찾는 문제
        // : 금액이 적은 것 부터 구매하도록 하면 최대한 많은 물건을 살 수 있다.

        // * 실행계획 *
        // 주어진 배열을 오름차순정렬한다.
        // for문을 돌면서 만약 가장 작은예산부터 주어진 예산과 비교해서 각 부서의 예산이
        // 작으면 전체예산에서 각 부서의 예산을 빼고 answer를 +1해준다.
        // 그리고 answer를 리턴한다.

        // * 문제풀면서 배운것
        // -- 자바에서 정렬에 관해서 정리 --
        // int 배열 오름차순 정렬 : Arrays.sort(int[] arr);
        // int 배열 내림차순 정렬 :
        // Integer[] tmp = Arrays.stream(intArray).boxed().toArray(Integer[]::new); // 각 원소 int -> Integer형
        // Arrays.sort(tmp, Comparator.reverseOrder());
        // String 배열 오름차순 정렬 : Arrays.sort(String[] arr);
        // String 배열 내림차순 정렬 : Arrays.sort(String[] arr, Comparator.reverseOrder());
````

- 항해99신대륙발견(항해99모의시험문제)
````
        // * 실행로직 *
        // 각 달의 일수를 나타내는 month배열을 만든다.
        // int addedDay에 98을 더한다.
        // 현재 month부터 계산한다.
        // while 반복문을 돌면서 현재 월에서부터 출발해서 배열의 최대일수만큼 빼준다.
````

###### 20221120(수) : 3문제
###### - 프로그래머스
- 숫자의 표현
````
        // # 문제의 이해
        // 어떤 수가 주어졌을 때 그 수가 연속으로 더해져서 나오는 구간을 찾는 문제

        // # 실행계획
        // 첫번째,반복문 속에 반복문이 돌아가야한다.
        // 반복문 바깥에 변수 loopCount를 선언해준다.
        // 반복문 while(true)를 선언하고 그 반복문안에서 한번 돌때마다 loopCount++(초기값:1)를 수행한다.
        // count 변수가 n이 될때까지 수행하면서 count 변수가 n이 되면 answer++을 수행하고 break를 해서 while문을 종료시킨다.
        //
        // 두번째, 반복문 속에서 loopCount를 기준으로 n까지 for문을 돈다.
        // for문을 돌면서 i를 반복문 바깥에 선언된 sum에다가 계속 더해간다.
        // 만약 더해지는 sum이 n보다 커지면 for문을 종료시킨다.
        // 만약 더해지는 sum이 n과 같아지면 answer를 선언하고 for문을 종료시킨다.
        // 종료된 for문 바깥에서 sum을 0으로 초기화해준다.

        // # 실행계획을 만들고 똑같이 코드를 작성해서 성공했는지 여부 : X
        // 이유 : 마지막 15의 경우를 포괄하지 못했다. loopCount가
        //       n이 되면 break를 하고 answer++을 수행해야하는데 그러지 못했다.

        // # 더 좋은 방법
        // - 두번째 회독때 생각해보기 => 종료조건과 실행과정의 로직이 겹친다.

        // # 문제푸는데 걸린시간 : 30분
        // # 에러를 만난 횟수 : 1번
````